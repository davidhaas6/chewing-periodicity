import dlib
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
import scipy.signal

def rect_to_bb(rect):
	# take a bounding predicted by dlib and convert it
	# to the format (x, y, w, h) as we would normally do
	# with OpenCV
	x = rect.left()
	y = rect.top()
	w = rect.right() - x
	h = rect.bottom() - y
	# return a tuple of (x, y, w, h)
	return (x, y, w, h)

def shape_to_np(shape, dtype="int"):
	# initialize the list of (x, y)-coordinates
	coords = np.zeros((68, 2), dtype=dtype)
	# loop over the 68 facial landmarks and convert them
	# to a 2-tuple of (x, y)-coordinates
	for i in range(0, 68):
		coords[i] = (shape.part(i).x, shape.part(i).y)
	# return the list of (x, y)-coordinates
	return coords

# # initialize dlib's face detector (HOG-based) and then create
# # the facial landmark predictor
# shape_predictor_path = 'shape_predictor_68_face_landmarks.dat'

# detector = dlib.get_frontal_face_detector()
# predictor = dlib.shape_predictor(shape_predictor_path)

# print('Dlib loaded')
# vstream = cv2.VideoCapture('longchew.mp4')
# frate = vstream.get(cv2.CAP_PROP_FPS)
# nframes = int(vstream.get(cv2.CAP_PROP_FRAME_COUNT))
# print('Stream loaded @ %i fps' % frate)

# distances = []
# for i in tqdm(range(nframes)):
#     _, image = vstream.read()
#     if image is None: 
#         break
#     image = cv2.resize(image, None, fx=.5, fy=.5)
#     gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    
#     rects = detector(gray, 1)  # detect faces in the grayscale image
#     if len(rects) == 0: 
#         continue

#     landmarks = shape_to_np(predictor(gray, rects[0]))  # Get landmakrs from detected faces

#     # https://www.pyimagesearch.com/wp-content/uploads/2017/04/facial_landmarks_68markup-1024x825.jpg
#     nose_point = landmarks[28,:]
#     chin_point = landmarks[9,:]

#     dist = np.linalg.norm(nose_point - chin_point)
#     distances += [dist]
#     # show the output image with the face detections + facial landmarks

#     # cv2.imshow("Output", image)
#     # cv2.waitKey(1)

def autocorr(x):
	# https://stackoverflow.com/a/47369584
    n = x.size
    norm = (x - np.mean(x))
    result = np.correlate(norm, norm, mode='same')
    acorr = result[n//2 + 1:] / (x.var() * np.arange(n-1, n//2, -1))
    lag = np.abs(acorr).argmax() + 1
    r = acorr[lag-1]        
    if np.abs(r) > 0.5:
      print('Appears to be autocorrelated with r = {}, lag = {}'. format(r, lag))
    else: 
      print('Appears to be not autocorrelated')
    return r, lag

# https://stackoverflow.com/questions/3694918/how-to-extract-frequency-associated-with-fft-values-in-python
# distances = [142.86357128393507, 141.718029904455, 141.718029904455, 138.91724155050014, 137.93114224133723, 137.11673858431726, 135.95955280891445, 137.11673858431726, 135.95955280891445, 136.31214179228496, 134.97407158413796, 136.13228860193308, 136.13228860193308, 135.14806694880988, 135.95955280891445, 136.6235704408284, 136.6235704408284, 139.5886814895821, 140.57738082636197, 141.56623891309678, 143.54441821262157, 144.68241081762497, 142.86357128393507, 140.73023839957068, 139.74262055650738, 138.91724155050014, 136.94524453225822, 134.97407158413796, 136.13228860193308, 134.97407158413796, 134.97407158413796, 134.97407158413796, 135.95955280891445, 135.79396157414365, 136.7808466123821, 136.7808466123821, 137.7679207943562, 138.6001443000692, 139.74262055650738, 140.57738082636197, 139.5886814895821, 134.80726983364065, 137.7679207943562, 136.7808466123821, 135.95955280891445, 134.80726983364065, 134.80726983364065, 134.80726983364065, 134.97407158413796, 133.98880550254935, 134.6476884316994, 134.97407158413796, 136.13228860193308, 134.80726983364065, 135.63554106501732, 136.4734406395618, 139.74262055650738, 139.44174410842686, 141.56623891309678, 143.54441821262157, 138.75518008348374, 136.6235704408284, 136.6235704408284, 134.80726983364065, 134.80726983364065, 134.80726983364065, 133.82077566656082, 133.82077566656082, 134.80726983364065, 134.80726983364065, 135.14806694880988, 135.79396157414365, 135.95955280891445, 136.6235704408284, 136.7808466123821, 139.74262055650738, 139.5886814895821, 139.74262055650738, 140.57738082636197, 141.56623891309678, 140.57738082636197, 140.8900280360537, 141.718029904455, 139.90353819685905, 140.07141035914503, 137.93114224133723, 136.13228860193308, 136.31214179228496, 136.94524453225822, 137.11673858431726, 135.95955280891445, 135.95955280891445, 135.79396157414365, 136.7808466123821, 138.6001443000692, 138.6001443000692, 139.44174410842686, 141.56623891309678, 142.70599146496969, 141.56623891309678, 142.70599146496969, 141.56623891309678, 139.74262055650738, 138.75518008348374, 138.6001443000692, 137.7679207943562, 137.7679207943562, 136.7808466123821, 136.7808466123821, 136.7808466123821, 135.95955280891445, 135.79396157414365, 135.79396157414365, 135.95955280891445, 135.95955280891445, 134.6476884316994, 135.79396157414365, 136.4734406395618, 137.46272221951665, 138.6001443000692, 138.75518008348374, 138.75518008348374, 138.6001443000692, 137.7679207943562, 136.6235704408284, 134.80726983364065, 135.95955280891445, 134.16407864998737, 134.16407864998737, 133.00375934536586, 133.00375934536586, 132.19682295728592, 133.18032887780387, 133.82077566656082, 133.98880550254935, 134.80726983364065, 136.6235704408284, 137.6117727521886, 139.5886814895821, 140.57738082636197, 140.73023839957068, 140.57738082636197, 140.57738082636197, 139.74262055650738, 138.91724155050014, 137.7679207943562, 136.7808466123821, 135.79396157414365, 137.11673858431726, 135.14806694880988, 134.34656675925888, 133.98880550254935, 133.98880550254935, 135.32922818075923, 134.34656675925888, 134.16407864998737, 133.98880550254935, 134.16407864998737, 134.16407864998737, 134.16407864998737, 134.80726983364065, 135.63554106501732, 137.93114224133723, 137.7679207943562, 137.93114224133723, 138.45215780189199, 138.75518008348374, 139.74262055650738, 137.93114224133723, 139.74262055650738, 137.7679207943562, 134.97407158413796, 136.13228860193308, 136.13228860193308, 135.79396157414365, 135.95955280891445, 133.98880550254935, 133.98880550254935, 135.95955280891445, 134.97407158413796, 135.14806694880988, 135.95955280891445, 137.11673858431726, 135.79396157414365, 137.6117727521886, 136.7808466123821, 139.74262055650738, 139.74262055650738, 140.8900280360537, 139.90353819685905, 139.90353819685905, 141.718029904455, 141.8767070381886, 139.08630414242805, 136.6235704408284, 135.95955280891445, 135.95955280891445, 137.11673858431726, 135.14806694880988, 136.13228860193308, 136.31214179228496, 135.14806694880988, 135.95955280891445, 135.14806694880988, 136.94524453225822, 136.13228860193308, 138.91724155050014, 137.93114224133723, 139.90353819685905, 139.90353819685905, 140.73023839957068, 140.73023839957068, 141.05672617780408, 138.91724155050014, 138.91724155050014, 138.91724155050014, 136.94524453225822, 137.93114224133723, 134.97407158413796, 135.95955280891445, 135.95955280891445, 134.97407158413796, 134.97407158413796, 133.82077566656082, 135.14806694880988, 134.16407864998737, 134.97407158413796, 135.95955280891445, 137.93114224133723, 136.6235704408284, 138.6001443000692, 139.44174410842686, 140.57738082636197, 142.27438279606065, 141.56623891309678, 141.56623891309678, 142.55525244620065, 139.74262055650738, 137.7679207943562, 134.97407158413796, 135.95955280891445, 135.14806694880988, 134.97407158413796, 134.97407158413796, 134.80726983364065, 134.97407158413796, 134.97407158413796, 135.14806694880988, 136.13228860193308, 135.95955280891445, 135.4843164355196, 137.7679207943562, 138.75518008348374, 138.75518008348374, 139.74262055650738, 139.5886814895821, 142.70599146496969, 141.56623891309678, 140.73023839957068, 138.6001443000692, 138.75518008348374, 136.7808466123821, 133.82077566656082, 133.82077566656082, 134.97407158413796, 133.98880550254935, 133.82077566656082, 133.82077566656082, 133.82077566656082, 135.95955280891445, 135.95955280891445, 134.80726983364065, 134.80726983364065, 136.6235704408284, 137.46272221951665, 139.44174410842686, 139.5886814895821, 140.57738082636197, 139.5886814895821, 140.73023839957068, 141.718029904455, 141.56623891309678, 141.718029904455, 137.46272221951665, 136.33048081775402, 134.4953530795767, 135.4843164355196, 134.6476884316994, 133.5065541462291, 133.6600164596728, 133.6600164596728, 134.6476884316994, 133.5065541462291, 135.63554106501732, 134.6476884316994]
frate = 30
x = np.load('longchew_dists.npy')

# Burstiness: https://stackoverflow.com/a/59142804

# x = np.array(distances)
# np.save('longchew_dists.npy', x)

autocorr(x)

norm = (x-x.mean())/x.std()

npoints = 300
w = np.abs(np.fft.fft(norm, npoints))[1:]
cycle_freqs = np.fft.fftfreq(npoints)[1:]
real = cycle_freqs > 0
hz = np.array([f * frate for f in cycle_freqs[real]])

fund_freq = hz[np.argmax(w[real])]
print("The fundamental frequency is", round(fund_freq,3), "Hz aka", round(fund_freq*60,1),"bpm")
plt.plot(hz, w[real])
plt.xlim(0,3)
plt.xlabel('Hz')
plt.show()

# w_psd = np.abs(w) ** 2
# freqs = np.fft.fftfreq(len(x))
# i = freqs != 0

# fig, ax = plt.subplots(1, 1, figsize=(8, 4))
# ax.plot(freqs[i], np.log10(w_psd[i]))
# ax.set_xlim(0, 1)
# ax.set_xlabel('Frequency (1/year)')
# ax.set_ylabel('PSD (dB)')

# fperiod = 1/frate
# plt.plot(np.arange(len(x) * fperiod, step=fperiod),x)
# plt.xlabel("time (s)")
# plt.show()
